---
layout: post
title: Cpp常用名称
date: 2019-11-08 17:45:20
description: Cpp常用名称
tag: C_CPP

---

- [1. c++常用名称](#1-c%e5%b8%b8%e7%94%a8%e5%90%8d%e7%a7%b0)
  - [1.1. 简介](#11-%e7%ae%80%e4%bb%8b)
  - [1.2. 名称解释](#12-%e5%90%8d%e7%a7%b0%e8%a7%a3%e9%87%8a)
    - [1.2.1. 表达式](#121-%e8%a1%a8%e8%be%be%e5%bc%8f)
    - [1.2.2. 左值(left value,lvalue)](#122-%e5%b7%a6%e5%80%bcleft-valuelvalue)
    - [1.2.3. 纯右值(pure rvalue,pralue)](#123-%e7%ba%af%e5%8f%b3%e5%80%bcpure-rvaluepralue)
    - [1.2.4. 将亡值(expiring value,xvalue)](#124-%e5%b0%86%e4%ba%a1%e5%80%bcexpiring-valuexvalue)
    - [1.2.5. T 模板类型](#125-t-%e6%a8%a1%e6%9d%bf%e7%b1%bb%e5%9e%8b)
    - [1.2.6. 良式](#126-%e8%89%af%e5%bc%8f)
  - [1.3. 参考资料](#13-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99)

# 1. c++常用名称

## 1.1. 简介

&emsp;&emsp;记录见到而不理解的名称

## 1.2. 名称解释

### 1.2.1. 表达式

定义：由运算符(operator)和运算对象(operand)构成的计算式（类似于数学上的算术表达式）。
举例：字面值(literal)和变量(variable)是最简单的表达式，函数的返回值也被认为是表达式。

### 1.2.2. 左值(left value,lvalue)

描述：能够用&取地址的表达式是左值表达式。
举例：

- 函数名和变量名（实际上是函数指针和具名变量，具名变量如std::cin、std::endl等）
- 返回左值引用的函数调用
- 前置自增/自减运算符连接的表达式++i/--i
- 由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）
- 解引用表达式*p
- 字符串字面值"abc"（关于这一点，后面会详细说明）

左值和将亡值合称泛左值(generalized lvalue,glvalue)

### 1.2.3. 纯右值(pure rvalue,pralue)

描述：满足下列条件之一：

- 本身就是赤裸裸的、纯粹的字面值，如3、false；
- 求值结果相当于字面值或是一个不具名的临时对象。

举例：

- 除字符串字面值以外的字面值
- 返回非引用类型的函数调用
- 后置自增/自减运算符连接的表达式i++/i--、
- 算术表达式（a+b、a&b、a<<b）
- 逻辑表达式（a&&b、a||b、~a）
- 比较表达式（a==b、a>=b、a<b）
- 取地址表达式（&a）。

下面从上面的例子中选取若干典型详细说明左值和纯右值的判断。

1）++i是左值，i++是右值。
    前者，对i加1后再赋给i，最终的返回值就是i，所以，++i的结果是具名的，名字就是i；而对于i++而言，是先对i进行一次拷贝，将得到的副本作为返回结果，然后再对i加1，由于i++的结果是对i加1前i的一份拷贝，所以它是不具名的。假设自增前i的值是6，那么，++i得到的结果是7，这个7有个名字，就是i；而i++得到的结果是6，这个6是i加1前的一个副本，它没有名字，i不是它的名字，i的值此时也是7。可见，++i和i++都达到了使i加1的目的，但两个表达式的结果不同。

2）解引用表达式*p是左值，取地址表达式&a是纯右值。
    &(*p)一定是正确的，因为*p得到的是p指向的实体，&(*p)得到的就是这一实体的地址，正是p的值。由于&(*p)的正确，所以*p是左值。而对&a而言，得到的是a的地址，相当于unsigned int型的字面值，所以是纯右值。

3）a+b、a&&b、a==b都是纯右值
    a+b得到的是不具名的临时对象，而a&&b和a==b的结果非true即false，相当于字面值。

纯右值和将亡值合称右值(right value,rvalue)

### 1.2.4. 将亡值(expiring value,xvalue)

描述：在C++11之前的右值和C++11中的纯右值是等价的。C++11中的将亡值是随着右值引用的引入而新引入的。换言之，“将亡值”概念的产生，是由右值引用的产生而引起的，将亡值与右值引用息息相关。所谓的将亡值表达式，就是下列表达式：

- 返回右值引用的函数的调用表达式
- 转换为右值引用的转换函数的调用表达式

读者会问：这与“将亡”有什么关系？
    在C++11中，我们用左值去初始化一个对象或为一个已有对象赋值时，会调用拷贝构造函数或拷贝赋值运算符来拷贝资源（所谓资源，就是指new出来的东西），而当我们用一个右值（包括纯右值和将亡值）来初始化或赋值时，会调用移动构造函数或移动赋值运算符⑤来移动资源，从而避免拷贝，提高效率（关于这些知识，在后续文章讲移动语义时，会详细介绍）。当该右值完成初始化或赋值的任务时，它的资源已经移动给了被初始化者或被赋值者，同时该右值也将会马上被销毁（析构）。也就是说，当一个右值准备完成初始化或赋值任务时，它已经“将亡”了。而上面1）和2）两种表达式的结果都是不具名的右值引用，它们属于右值（关于“不具名的右值引用是右值”这一点，后面还会详细解释）。又因为
       1）这种右值是与C++11新生事物——“右值引用”相关的“新右值”
       2）这种右值常用来完成移动构造或移动赋值的特殊任务，扮演着“将亡”的角色
       所以C++11给这类右值起了一个新的名字——将亡值。
举例
       std::move()、tsatic_cast<X&&>(x)（X是自定义的类，x是类对象，这两个函数常用来将左值强制转换成右值，从而使拷贝变成移动，提高效率，关于这些，后续文章中会详细介绍。）
附注
      事实上，将亡值不过是C++11提出的一块晦涩的语法糖。它与纯右值在功能上及其相似，如都不能做操作符的左操作数，都可以使用移动构造函数和移动赋值运算符。当一个纯右值来完成移动构造或移动赋值任务⑥时，其实它也具有“将亡”的特点。一般我们不必刻意区分一个右值到底是纯右值还是将亡值。  

      关于“三值”的大体介绍，就到此结束了。想要获知更加详细的内容，读者可以参考cppreference上的文章：
      http://naipc.uchicago.edu/2015/ref/cppreference/en/cpp/language/value_category.html （精简版）  
      和
      http://en.cppreference.com/w/cpp/language/value_category  （详细版）
      文章对“三值”进行了详细地讲述，同时讲出了将左值和将亡值合称泛左值的原因（这是本文未详细讨论的），如两者都可以使用多态，都可以隐式转换成纯右值，都可以是不完全类型（incomplete type）等。之所以不展开叙述，是因为在下实在举不出合适的代码来加以佐证。这里在下恳请各位读者不吝赐教。另外，关于文章（特别是详细版）中的一些观点，在下不敢苟同，篇幅原因，在下就不一一叙述了。

### 1.2.5. T 模板类型

### 1.2.6. 良式

## 1.3. 参考资料

1. [值类别](https://zh.cppreference.com/w/cpp/language/value_category)
2. [话说C++中的左值、纯右值、将亡值](https://www.cnblogs.com/zpcdbky/p/5275959.html)
