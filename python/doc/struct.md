# 1. struct

- [1. struct](#1-struct)
  - [1.1. 简介](#11-简介)
  - [1.2. 注意事项](#12-注意事项)
  - [1.3. 函数](#13-函数)
  - [1.4. 字节顺序，大小和对齐方式](#14-字节顺序大小和对齐方式)
  - [1.5. 格式](#15-格式)
  - [1.6. 参考资料](#16-参考资料)

## 1.1. 简介

struct --- 将字节串解读为打包的二进制数据

此模块可以执行 Python 值和以 Python bytes 对象表示的 C 结构之间的转换。 这可以被用来处理存储在文件中或是从网络连接等其他来源获取的二进制数据。 它使用 格式字符串 作为 C 结构布局的精简描述以及与 Python 值的双向转换。

## 1.2. 注意事项

1. 注意对齐方式的使用，默认会进行对齐，所以需要特别注意。

## 1.3. 函数

`exception struct.error`
会在多种场合下被引发的异常；其参数为一个描述错误信息的字符串。

`struct.pack(format, v1, v2, ...)`
返回一个 bytes 对象，其中包含根据格式字符串 format 打包的值 v1, v2, ... 参数个数必须与格式字符串所要求的值完全匹配。

`struct.pack_into(format, buffer, offset, v1, v2, ...)`
根据格式字符串 format 打包 v1, v2, ... 等值并将打包的字节串写入可写缓冲区 buffer 从 offset 开始的位置。 请注意 offset 是必需的参数。

`struct.unpack(format, buffer)`
根据格式字符串 format 从缓冲区 buffer 解包（假定是由 pack(format, ...) 打包）。 结果为一个元组，即使其只包含一个条目。 缓冲区的字节大小必须匹配格式所要求的大小，如 calcsize() 所示。

`struct.unpack_from(format, buffer, offset=0)`
对 buffer 从位置 offset 开始根据格式字符串 format 进行解包。 结果为一个元组，即使其中只包含一个条目。 缓冲区的字节大小从位置 offset 开始必须至少为 calcsize() 显示的格式所要求的大小。

`struct.iter_unpack(format, buffer)`
根据格式字符串 format 以迭代方式从缓冲区 buffer 解包。 此函数返回一个迭代器，它将从缓冲区读取相同大小的块直至其内容全部耗尽。 缓冲区的字节大小必须整数倍于格式所要求的大小，如 calcsize() 所示。
每次迭代将产生一个如格式字符串所指定的元组。

3.4 新版功能.

`struct.calcsize(format)`
返回与格式字符串 format 相对应的结构的大小（亦即 pack(format, ...) 所产生的字节串对象的大小）。

- `class struct.Struct(format)`
  - 返回一个新的 Struct 对象，它会根据格式字符串 format 来写入和读取二进制数据。 一次性地创建 Struct 对象并调用其方法相比使用同样的格式调用 struct 函数更为高效，因为这样格式字符串只需被编译一次。
  - 注解 传递给 Struct 和模块层级函数的已编译版最新格式字符串会被缓存，因此只使用少量格式字符串的程序无需担心重用单独的 Struct 实例。
  - 已编译的 Struct 对象支持以下方法和属性：
    - `pack(v1, v2, ...)`等价于 pack() 函数
    - `pack_into(buffer, offset, v1, v2, ...)`等价于 pack_into() 函数
    - `unpack(buffer)`等价于 unpack() 函数
    - `unpack_from(buffer, offset=0)`等价于 unpack_from() 函数
    - `iter_unpack(buffer)`等价于 iter_unpack() 函数
    - `format`用于构造此 Struct 对象的格式字符串。在 3.7 版更改: 格式字符串类型现在是 str 而不再是 bytes。
    - `size`计算出对应于 format 的结构大小（亦即 pack() 方法所产生的字节串对象的大小）。

## 1.4. 字节顺序，大小和对齐方式

| 字符 | 字节顺序      | 大小     | 对齐方式 |
| ---- | ------------- | -------- | -------- |
| @    | 按原字节      | 按原字节 | 按原字节 | 默认设置 |
| =    | 按原字节      | 标准     | 无       |
| <    | 小端          | 标准     | 无       |
| >    | 大端          | 标准     | 无       |
| !    | 网络（=大端） | 标准     | 无       |

1. 请注意 '@' 和 '=' 之间的区别：两个都使用本机字节顺序，但后者的大小和对齐方式是标准化的。
2. 本机字节顺序可能为大端或是小端，取决于主机系统的不同。
3. Intel x86 和 AMD64 (x86-64) 是小端的；
4. Motorola 68000 和 PowerPC G5 是大端的；
5. ARM 和 Intel Itanium 具有可切换的字节顺序（双端）。 请使用 sys.byteorder 来检查你的系统字节顺序。

## 1.5. 格式

1. 格式字符之前可以带有整数重复计数。 例如，格式字符串 '4h' 的含义与 'hhhh' 完全相同。

| 格式 | C 类型             | Python 类型       | 标准大小 | 注释     |
| ---- | ------------------ | ----------------- | -------- | -------- |
| x    | 填充字节           | 无                |
| c    | char               | 长度为 1 的字节串 | 1        |
| b    | signed char        | 整数              | 1        | (1), (2) |
| B    | unsigned char      | 整数              | 1        | (2)      |
| ?    | _Bool              | bool              | 1        | (1)      |
| h    | short              | 整数              | 2        | (2)      |
| H    | unsigned short     | 整数              | 2        | (2)      |
| i    | int                | 整数              | 4        | (2)      |
| I    | unsigned int       | 整数              | 4        | (2)      |
| l    | long               | 整数              | 4        | (2)      |
| L    | unsigned long      | 整数              | 4        | (2)      |
| q    | long long          | 整数              | 8        | (2)      |
| Q    | unsigned long long | 整数              | 8        | (2)      |
| n    | ssize_t            | 整数              | (3)      |
| N    | size_t             | 整数              | (3)      |
| e    | (6)                | float             | 2        | (4)      |
| f    | float              | float             | 4        | (4)      |
| d    | double             | float             | 8        | (4)      |
| s    | char[]             | 字节串            | (7)      |
| p    | char[]             | 字节串            | (8)      |
| P    | void *             | 整数              | (5)      |

注释:

1. '?' 转换码对应于 C99 定义的 _Bool 类型。 如果此类型不可用，则使用 char 来模拟。 在标准模式下，它总是以一个字节表示。
2. 当尝试使用任何整数转换码打包一个非整数时，如果该非整数具有 __index__() 方法，则会在打包之前调用该方法将参数转换为一个整数。
在 3.2 版更改: 为非整数使用 __index__() 方法是 3.2 版的新增特性。
3. 'n' 和 'N' 转换码仅对本机大小可用（选择为默认或使用 '@' 字节顺序字符）。 对于标准大小，你可以使用适合你的应用的任何其他整数格式。在32位系统上 定义为 unsigned int， 在64位系统上定义为 unsigned long
4. 对于 'f', 'd' 和 'e' 转换码，打包表示形式将使用 IEEE 754 binary32, binary64 或 binary16 格式 (分别对应于 'f', 'd' 或 'e')，无论平台使用何种浮点格式。
5. 'P' 格式字符仅对本机字节顺序可用（选择为默认或使用 '@' 字节顺序字符）。 字节顺序字符 '=' 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解读为本机排序，因此 'P' 格式将不可用。
6. IEEE 754 binary16 "半精度" 类型是在 IEEE 754 标准 的 2008 修订版中引入的。 它包含一个符号位，5 个指数位和 11 个精度位（明确存储 10 位），可以完全精确地表示大致范围在 6.1e-05 和 6.5e+04 之间的数字。 此类型并不被 C 编译器广泛支持：在一台典型的机器上，可以使用 unsigned short 进行存储，但不会被用于数学运算。 请参阅维基百科页面 half-precision floating-point format 了解详情。
7. 对于 's' 格式字符，计数会被解析为字节的长度，而不是像其他格式字符那样的重复计数；例如，'10s' 表示一个 10 字节的字节串，而 '10c' 表示 10 个字符。 如果未给出计数，则默认值为 1
8. 'p' 格式字符用于编码“Pascal 字符串”，首字符是长度(最长255)，后边是内容。

## 1.6. 参考资料

1. [struct](https://docs.python.org/zh-cn/3/library/struct.html)
